Origami.canvas = document.getElementById("c");Mouse.init(Origami.canvas, document.getElementById("c"));document.getElementById("update").addEventListener("click", function(e){	Ripples.size.w = document.getElementById("gridSizeX").value*1;	Ripples.size.h = document.getElementById("gridSizeY").value*1;	Ripples.wave.speed = document.getElementById("waveSpeed").value*1;	Ripples.wave.frequency = document.getElementById("waveFrequency").value*1;	Ripples.wave.magnitude = document.getElementById("waveMagnitude").value*1;	if(document.getElementById("waveEquationLinear").checked){		Ripples.wave.equation = Ripples.wave.equations.linear;	}else if(document.getElementById("waveEquationDiagonal").checked){		Ripples.wave.equation = Ripples.wave.equations.diagonal;	}else if(document.getElementById("waveEquationRadial").checked){		Ripples.wave.equation = Ripples.wave.equations.sinc;	}	Animation.stop();	Ripples.createWorld();}, false);Origami.cam = {	"x":-660, 	"y":100, 	"z":-13, 	"rx":0.405, 	"ry":1.54, 	"rz":0, 	"depth":350};Mouse.pos.z = 50;var Ripples = {};Ripples.size = {w:20, h:15};Ripples.createWorld = function(){	Origami.world = {};	Origami.world.light = {		"sun":{			"x":0,			"y":0,			"z":0,			"yr":0,			"power":1		},		"ambient":0.0	};	var textures = [{		image: 1,		s:0.5	}];	var points = [];	var polygons = [];		var w = Ripples.size.w;	var h = Ripples.size.h;		var imgW = 800;	var imgH = 600;		var rectW = 800;	var rectH = 600;			for(var y=0; y<h; y++){		for(var x=0; x<w; x++){			points.push({x:x/w*rectW - rectW/2, y:0, z:y/h*rectH - rectH/2});			if(x>0 && y>0){				polygons.push({					v1:(y-1)*w + (x-1),					v2:(y-1)*w + (x-0),					v3:(y-0)*w + (x-1),					texture:textures.length				});				textures.push({					image: 0, 					p1: {x:(x-1)/(w-1)*imgW,						 y:(y-1)/(h-1)*imgH}, 					p2: {x:(x-0)/(w-1)*imgW,						 y:(y-1)/(h-1)*imgH},  					p3: {x:(x-1)/(w-1)*imgW,						 y:(y-0)/(h-1)*imgH}					}				);				polygons.push({					v1:(y-0)*w + (x-0),					v3:(y-1)*w + (x-0),					v2:(y-0)*w + (x-1),					texture:textures.length				});				textures.push({					image: 0, 					p1: {x:(x-0)/(w-1)*imgW,						 y:(y-0)/(h-1)*imgH}, 					p3: {x:(x-0)/(w-1)*imgW,						 y:(y-1)/(h-1)*imgH},  					p2: {x:(x-1)/(w-1)*imgW,						 y:(y-0)/(h-1)*imgH}					}				);			}		}	}	Origami.world.textures = textures;	Origami.world.images = [{		url: "gfx/windowsXP.jpg"	},	{		url: "gfx/sun.png"	}];	Origami.world.shapes = [{		verts: points,		polygons: polygons,		type: "polygon"	},	{		type:"2DSprite",		texture:0,		x:0,		y:0,		z:1000	}];	Origami.initWorld(function(){		Animation.start(Ripples.redrawWorld);		//Ripples.intval = setInterval(Ripples.redrawWorld, 20);	});}Ripples.downPos = {x:0, y:0};Ripples.wave = {};Ripples.wave.phase=0;Ripples.wave.speed = 1Ripples.wave.frequency = 4;Ripples.wave.magnitude = 50;Ripples.wave.equations = {};Ripples.wave.equations.linear = function(x, y){	return Math.sin(Ripples.wave.phase+x*Ripples.wave.frequency/10)*Ripples.wave.magnitude;}Ripples.wave.equations.diagonal = function(x, y){	return Math.sin(Ripples.wave.phase+(x+y)*Ripples.wave.frequency/10)*Ripples.wave.magnitude;}Ripples.wave.equations.sinc = function(x, y){	var dist = Math.sqrt((Ripples.size.w/2 - x)*(Ripples.size.w/2 - x) + (Ripples.size.h/2 - y)*(Ripples.size.h/2 - y));	return Math.sin(Ripples.wave.phase-dist*Ripples.wave.frequency/10)*Ripples.wave.magnitude*10/(dist+10);}Ripples.wave.equation = Ripples.wave.equations.sinc;Ripples.ripple = function(){	Ripples.wave.phase += Ripples.wave.speed/10;	var map = Origami.world.shapes[0].verts;	var w = Ripples.size.w;	var h = Ripples.size.h;	for(var y=0; y<h; y++){		for(var x=0; x<w; x++){			map[y*w + x].y = Ripples.wave.equation(x, y);		}	}	var polygons = Origami.world.shapes[0].polygons;	for(var i=0; i<polygons.length; i++){		var polygon = polygons[i];		polygon.normal = {x:(polygon.v2.y - polygon.v1.y)*(polygon.v3.z - polygon.v1.z) - (polygon.v2.z - polygon.v1.z)*(polygon.v3.y - polygon.v1.y), 				  y:(polygon.v2.z - polygon.v1.z)*(polygon.v3.x - polygon.v1.x) - (polygon.v2.x - polygon.v1.x)*(polygon.v3.z - polygon.v1.z),				  z:(polygon.v2.x - polygon.v1.x)*(polygon.v3.y - polygon.v1.y) - (polygon.v2.y - polygon.v1.y)*(polygon.v3.x - polygon.v1.x)};		l = Math.sqrt(polygon.normal.x*polygon.normal.x + polygon.normal.y*polygon.normal.y + polygon.normal.z*polygon.normal.z);		polygon.normal.x/=l;		polygon.normal.y/=l;		polygon.normal.z/=l;	}	}Ripples.redrawWorld = function(){	var sun = Origami.world.light.sun;	sun.yr -= 1/90;	sun.x = Math.sin(sun.yr);	sun.y = 1/2;	sun.z = Math.cos(sun.yr);	if(Origami.world.shapes.length > 1){		Origami.world.shapes[1].x = sun.x*600;		Origami.world.shapes[1].y = sun.y*600;		Origami.world.shapes[1].z = sun.z*600;	}	var radius = Mouse.pos.z*10;	if(Mouse.isPressed(0)){		Ripples.downPos.x = Mouse.pos.x;		Ripples.downPos.y = Mouse.pos.y;	}	if(Mouse.isDown(0)){		Origami.cam.ry += (Ripples.downPos.x-Mouse.pos.x)/Origami.size.hw*Math.PI;		Origami.cam.rx -= (Ripples.downPos.y-Mouse.pos.y)/Origami.size.h*Math.PI;		Origami.cam.rx = Math.max(Origami.cam.rx, 0);		Ripples.downPos.x = Mouse.pos.x;		Ripples.downPos.y = Mouse.pos.y;	}	Origami.cam.y = Math.sin(Origami.cam.rx)*radius;	var r = Math.cos(Origami.cam.rx)*radius;	Origami.cam.x = -Math.sin(Origami.cam.ry)*r;	Origami.cam.z = -Math.cos(Origami.cam.ry)*r;		Ripples.ripple();	Origami.ctx.lineStyle = "transparent";	Origami.render();	FPS.frameComplete();	Origami.ctx.fillText(Origami.statistics.polyCount+" Polygons", 0, 15);}Ripples.createWorld();